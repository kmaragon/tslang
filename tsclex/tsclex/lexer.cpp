/*
 * TSCC - a Typescript Compiler
 * Copyright (c) 2025. Keef Aragon
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "lexer.hpp"
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include "error/expected_command.hpp"
#include "error/hexidecimal_digit_expected.hpp"
#include "error/invalid_character.hpp"
#include "error/invalid_identifier.hpp"
#include "error/misplaced_shebang.hpp"
#include "error/multiple_separators_not_allowed.hpp"
#include "error/separators_not_allowed_here.hpp"
#include "error/unexpected_end_of_text.hpp"
#include "error/unicode_value_out_of_range.hpp"
#include "error/unterminated_multiline_comment.hpp"
#include "error/unterminated_string_literal.hpp"
#include "error/unterminated_unicode_escape_sequence.hpp"
#include "token.hpp"

using namespace tscc::lex;

std::array<char32_t, 512> lexer::unicode_es3_identifier_start{
	170,   170,	  181,	 181,	186,   186,	  192,	 214,	216,   246,	  248,
	543,   546,	  563,	 592,	685,   688,	  696,	 699,	705,   720,	  721,
	736,   740,	  750,	 750,	890,   890,	  902,	 902,	904,   906,	  908,
	908,   910,	  929,	 931,	974,   976,	  983,	 986,	1011,  1024,  1153,
	1164,  1220,  1223,	 1224,	1227,  1228,  1232,	 1269,	1272,  1273,  1329,
	1366,  1369,  1369,	 1377,	1415,  1488,  1514,	 1520,	1522,  1569,  1594,
	1600,  1610,  1649,	 1747,	1749,  1749,  1765,	 1766,	1786,  1788,  1808,
	1808,  1810,  1836,	 1920,	1957,  2309,  2361,	 2365,	2365,  2384,  2384,
	2392,  2401,  2437,	 2444,	2447,  2448,  2451,	 2472,	2474,  2480,  2482,
	2482,  2486,  2489,	 2524,	2525,  2527,  2529,	 2544,	2545,  2565,  2570,
	2575,  2576,  2579,	 2600,	2602,  2608,  2610,	 2611,	2613,  2614,  2616,
	2617,  2649,  2652,	 2654,	2654,  2674,  2676,	 2693,	2699,  2701,  2701,
	2703,  2705,  2707,	 2728,	2730,  2736,  2738,	 2739,	2741,  2745,  2749,
	2749,  2768,  2768,	 2784,	2784,  2821,  2828,	 2831,	2832,  2835,  2856,
	2858,  2864,  2866,	 2867,	2870,  2873,  2877,	 2877,	2908,  2909,  2911,
	2913,  2949,  2954,	 2958,	2960,  2962,  2965,	 2969,	2970,  2972,  2972,
	2974,  2975,  2979,	 2980,	2984,  2986,  2990,	 2997,	2999,  3001,  3077,
	3084,  3086,  3088,	 3090,	3112,  3114,  3123,	 3125,	3129,  3168,  3169,
	3205,  3212,  3214,	 3216,	3218,  3240,  3242,	 3251,	3253,  3257,  3294,
	3294,  3296,  3297,	 3333,	3340,  3342,  3344,	 3346,	3368,  3370,  3385,
	3424,  3425,  3461,	 3478,	3482,  3505,  3507,	 3515,	3517,  3517,  3520,
	3526,  3585,  3632,	 3634,	3635,  3648,  3654,	 3713,	3714,  3716,  3716,
	3719,  3720,  3722,	 3722,	3725,  3725,  3732,	 3735,	3737,  3743,  3745,
	3747,  3749,  3749,	 3751,	3751,  3754,  3755,	 3757,	3760,  3762,  3763,
	3773,  3773,  3776,	 3780,	3782,  3782,  3804,	 3805,	3840,  3840,  3904,
	3911,  3913,  3946,	 3976,	3979,  4096,  4129,	 4131,	4135,  4137,  4138,
	4176,  4181,  4256,	 4293,	4304,  4342,  4352,	 4441,	4447,  4514,  4520,
	4601,  4608,  4614,	 4616,	4678,  4680,  4680,	 4682,	4685,  4688,  4694,
	4696,  4696,  4698,	 4701,	4704,  4742,  4744,	 4744,	4746,  4749,  4752,
	4782,  4784,  4784,	 4786,	4789,  4792,  4798,	 4800,	4800,  4802,  4805,
	4808,  4814,  4816,	 4822,	4824,  4846,  4848,	 4878,	4880,  4880,  4882,
	4885,  4888,  4894,	 4896,	4934,  4936,  4954,	 5024,	5108,  5121,  5740,
	5743,  5750,  5761,	 5786,	5792,  5866,  6016,	 6067,	6176,  6263,  6272,
	6312,  7680,  7835,	 7840,	7929,  7936,  7957,	 7960,	7965,  7968,  8005,
	8008,  8013,  8016,	 8023,	8025,  8025,  8027,	 8027,	8029,  8029,  8031,
	8061,  8064,  8116,	 8118,	8124,  8126,  8126,	 8130,	8132,  8134,  8140,
	8144,  8147,  8150,	 8155,	8160,  8172,  8178,	 8180,	8182,  8188,  8319,
	8319,  8450,  8450,	 8455,	8455,  8458,  8467,	 8469,	8469,  8473,  8477,
	8484,  8484,  8486,	 8486,	8488,  8488,  8490,	 8493,	8495,  8497,  8499,
	8505,  8544,  8579,	 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346,
	12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593,
	12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203,
	63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298,
	64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,
	64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140,
	65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479,
	65482, 65487, 65490, 65495, 65498, 65500};
std::array<char32_t, 684> lexer::unicode_es3_identifier_part{
	170,   170,	  181,	 181,	186,   186,	  192,	 214,	216,   246,	  248,
	543,   546,	  563,	 592,	685,   688,	  696,	 699,	705,   720,	  721,
	736,   740,	  750,	 750,	768,   846,	  864,	 866,	890,   890,	  902,
	902,   904,	  906,	 908,	908,   910,	  929,	 931,	974,   976,	  983,
	986,   1011,  1024,	 1153,	1155,  1158,  1164,	 1220,	1223,  1224,  1227,
	1228,  1232,  1269,	 1272,	1273,  1329,  1366,	 1369,	1369,  1377,  1415,
	1425,  1441,  1443,	 1465,	1467,  1469,  1471,	 1471,	1473,  1474,  1476,
	1476,  1488,  1514,	 1520,	1522,  1569,  1594,	 1600,	1621,  1632,  1641,
	1648,  1747,  1749,	 1756,	1759,  1768,  1770,	 1773,	1776,  1788,  1808,
	1836,  1840,  1866,	 1920,	1968,  2305,  2307,	 2309,	2361,  2364,  2381,
	2384,  2388,  2392,	 2403,	2406,  2415,  2433,	 2435,	2437,  2444,  2447,
	2448,  2451,  2472,	 2474,	2480,  2482,  2482,	 2486,	2489,  2492,  2492,
	2494,  2500,  2503,	 2504,	2507,  2509,  2519,	 2519,	2524,  2525,  2527,
	2531,  2534,  2545,	 2562,	2562,  2565,  2570,	 2575,	2576,  2579,  2600,
	2602,  2608,  2610,	 2611,	2613,  2614,  2616,	 2617,	2620,  2620,  2622,
	2626,  2631,  2632,	 2635,	2637,  2649,  2652,	 2654,	2654,  2662,  2676,
	2689,  2691,  2693,	 2699,	2701,  2701,  2703,	 2705,	2707,  2728,  2730,
	2736,  2738,  2739,	 2741,	2745,  2748,  2757,	 2759,	2761,  2763,  2765,
	2768,  2768,  2784,	 2784,	2790,  2799,  2817,	 2819,	2821,  2828,  2831,
	2832,  2835,  2856,	 2858,	2864,  2866,  2867,	 2870,	2873,  2876,  2883,
	2887,  2888,  2891,	 2893,	2902,  2903,  2908,	 2909,	2911,  2913,  2918,
	2927,  2946,  2947,	 2949,	2954,  2958,  2960,	 2962,	2965,  2969,  2970,
	2972,  2972,  2974,	 2975,	2979,  2980,  2984,	 2986,	2990,  2997,  2999,
	3001,  3006,  3010,	 3014,	3016,  3018,  3021,	 3031,	3031,  3047,  3055,
	3073,  3075,  3077,	 3084,	3086,  3088,  3090,	 3112,	3114,  3123,  3125,
	3129,  3134,  3140,	 3142,	3144,  3146,  3149,	 3157,	3158,  3168,  3169,
	3174,  3183,  3202,	 3203,	3205,  3212,  3214,	 3216,	3218,  3240,  3242,
	3251,  3253,  3257,	 3262,	3268,  3270,  3272,	 3274,	3277,  3285,  3286,
	3294,  3294,  3296,	 3297,	3302,  3311,  3330,	 3331,	3333,  3340,  3342,
	3344,  3346,  3368,	 3370,	3385,  3390,  3395,	 3398,	3400,  3402,  3405,
	3415,  3415,  3424,	 3425,	3430,  3439,  3458,	 3459,	3461,  3478,  3482,
	3505,  3507,  3515,	 3517,	3517,  3520,  3526,	 3530,	3530,  3535,  3540,
	3542,  3542,  3544,	 3551,	3570,  3571,  3585,	 3642,	3648,  3662,  3664,
	3673,  3713,  3714,	 3716,	3716,  3719,  3720,	 3722,	3722,  3725,  3725,
	3732,  3735,  3737,	 3743,	3745,  3747,  3749,	 3749,	3751,  3751,  3754,
	3755,  3757,  3769,	 3771,	3773,  3776,  3780,	 3782,	3782,  3784,  3789,
	3792,  3801,  3804,	 3805,	3840,  3840,  3864,	 3865,	3872,  3881,  3893,
	3893,  3895,  3895,	 3897,	3897,  3902,  3911,	 3913,	3946,  3953,  3972,
	3974,  3979,  3984,	 3991,	3993,  4028,  4038,	 4038,	4096,  4129,  4131,
	4135,  4137,  4138,	 4140,	4146,  4150,  4153,	 4160,	4169,  4176,  4185,
	4256,  4293,  4304,	 4342,	4352,  4441,  4447,	 4514,	4520,  4601,  4608,
	4614,  4616,  4678,	 4680,	4680,  4682,  4685,	 4688,	4694,  4696,  4696,
	4698,  4701,  4704,	 4742,	4744,  4744,  4746,	 4749,	4752,  4782,  4784,
	4784,  4786,  4789,	 4792,	4798,  4800,  4800,	 4802,	4805,  4808,  4814,
	4816,  4822,  4824,	 4846,	4848,  4878,  4880,	 4880,	4882,  4885,  4888,
	4894,  4896,  4934,	 4936,	4954,  4969,  4977,	 5024,	5108,  5121,  5740,
	5743,  5750,  5761,	 5786,	5792,  5866,  6016,	 6099,	6112,  6121,  6160,
	6169,  6176,  6263,	 6272,	6313,  7680,  7835,	 7840,	7929,  7936,  7957,
	7960,  7965,  7968,	 8005,	8008,  8013,  8016,	 8023,	8025,  8025,  8027,
	8027,  8029,  8029,	 8031,	8061,  8064,  8116,	 8118,	8124,  8126,  8126,
	8130,  8132,  8134,	 8140,	8144,  8147,  8150,	 8155,	8160,  8172,  8178,
	8180,  8182,  8188,	 8255,	8256,  8319,  8319,	 8400,	8412,  8417,  8417,
	8450,  8450,  8455,	 8455,	8458,  8467,  8469,	 8469,	8473,  8477,  8484,
	8484,  8486,  8486,	 8488,	8488,  8490,  8493,	 8495,	8497,  8499,  8505,
	8544,  8579,  12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353,
	12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686,
	12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744,
	64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316,
	64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848,
	64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103,
	65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343,
	65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495,
	65498, 65500};
std::array<char32_t, 740> lexer::unicode_es5_identifier_start{
	170,   170,	  181,	 181,	186,   186,	  192,	 214,	216,   246,	  248,
	705,   710,	  721,	 736,	740,   748,	  748,	 750,	750,   880,	  884,
	886,   887,	  890,	 893,	902,   902,	  904,	 906,	908,   908,	  910,
	929,   931,	  1013,	 1015,	1153,  1162,  1319,	 1329,	1366,  1369,  1369,
	1377,  1415,  1488,	 1514,	1520,  1522,  1568,	 1610,	1646,  1647,  1649,
	1747,  1749,  1749,	 1765,	1766,  1774,  1775,	 1786,	1788,  1791,  1791,
	1808,  1808,  1810,	 1839,	1869,  1957,  1969,	 1969,	1994,  2026,  2036,
	2037,  2042,  2042,	 2048,	2069,  2074,  2074,	 2084,	2084,  2088,  2088,
	2112,  2136,  2208,	 2208,	2210,  2220,  2308,	 2361,	2365,  2365,  2384,
	2384,  2392,  2401,	 2417,	2423,  2425,  2431,	 2437,	2444,  2447,  2448,
	2451,  2472,  2474,	 2480,	2482,  2482,  2486,	 2489,	2493,  2493,  2510,
	2510,  2524,  2525,	 2527,	2529,  2544,  2545,	 2565,	2570,  2575,  2576,
	2579,  2600,  2602,	 2608,	2610,  2611,  2613,	 2614,	2616,  2617,  2649,
	2652,  2654,  2654,	 2674,	2676,  2693,  2701,	 2703,	2705,  2707,  2728,
	2730,  2736,  2738,	 2739,	2741,  2745,  2749,	 2749,	2768,  2768,  2784,
	2785,  2821,  2828,	 2831,	2832,  2835,  2856,	 2858,	2864,  2866,  2867,
	2869,  2873,  2877,	 2877,	2908,  2909,  2911,	 2913,	2929,  2929,  2947,
	2947,  2949,  2954,	 2958,	2960,  2962,  2965,	 2969,	2970,  2972,  2972,
	2974,  2975,  2979,	 2980,	2984,  2986,  2990,	 3001,	3024,  3024,  3077,
	3084,  3086,  3088,	 3090,	3112,  3114,  3123,	 3125,	3129,  3133,  3133,
	3160,  3161,  3168,	 3169,	3205,  3212,  3214,	 3216,	3218,  3240,  3242,
	3251,  3253,  3257,	 3261,	3261,  3294,  3294,	 3296,	3297,  3313,  3314,
	3333,  3340,  3342,	 3344,	3346,  3386,  3389,	 3389,	3406,  3406,  3424,
	3425,  3450,  3455,	 3461,	3478,  3482,  3505,	 3507,	3515,  3517,  3517,
	3520,  3526,  3585,	 3632,	3634,  3635,  3648,	 3654,	3713,  3714,  3716,
	3716,  3719,  3720,	 3722,	3722,  3725,  3725,	 3732,	3735,  3737,  3743,
	3745,  3747,  3749,	 3749,	3751,  3751,  3754,	 3755,	3757,  3760,  3762,
	3763,  3773,  3773,	 3776,	3780,  3782,  3782,	 3804,	3807,  3840,  3840,
	3904,  3911,  3913,	 3948,	3976,  3980,  4096,	 4138,	4159,  4159,  4176,
	4181,  4186,  4189,	 4193,	4193,  4197,  4198,	 4206,	4208,  4213,  4225,
	4238,  4238,  4256,	 4293,	4295,  4295,  4301,	 4301,	4304,  4346,  4348,
	4680,  4682,  4685,	 4688,	4694,  4696,  4696,	 4698,	4701,  4704,  4744,
	4746,  4749,  4752,	 4784,	4786,  4789,  4792,	 4798,	4800,  4800,  4802,
	4805,  4808,  4822,	 4824,	4880,  4882,  4885,	 4888,	4954,  4992,  5007,
	5024,  5108,  5121,	 5740,	5743,  5759,  5761,	 5786,	5792,  5866,  5870,
	5872,  5888,  5900,	 5902,	5905,  5920,  5937,	 5952,	5969,  5984,  5996,
	5998,  6000,  6016,	 6067,	6103,  6103,  6108,	 6108,	6176,  6263,  6272,
	6312,  6314,  6314,	 6320,	6389,  6400,  6428,	 6480,	6509,  6512,  6516,
	6528,  6571,  6593,	 6599,	6656,  6678,  6688,	 6740,	6823,  6823,  6917,
	6963,  6981,  6987,	 7043,	7072,  7086,  7087,	 7098,	7141,  7168,  7203,
	7245,  7247,  7258,	 7293,	7401,  7404,  7406,	 7409,	7413,  7414,  7424,
	7615,  7680,  7957,	 7960,	7965,  7968,  8005,	 8008,	8013,  8016,  8023,
	8025,  8025,  8027,	 8027,	8029,  8029,  8031,	 8061,	8064,  8116,  8118,
	8124,  8126,  8126,	 8130,	8132,  8134,  8140,	 8144,	8147,  8150,  8155,
	8160,  8172,  8178,	 8180,	8182,  8188,  8305,	 8305,	8319,  8319,  8336,
	8348,  8450,  8450,	 8455,	8455,  8458,  8467,	 8469,	8469,  8473,  8477,
	8484,  8484,  8486,	 8486,	8488,  8488,  8490,	 8493,	8495,  8505,  8508,
	8511,  8517,  8521,	 8526,	8526,  8544,  8584,	 11264, 11310, 11312, 11358,
	11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565,
	11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,
	11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736,
	11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348,
	12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593,
	12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124,
	42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623,
	42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899,
	42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072,
	43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334,
	43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588,
	43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702,
	43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762,
	43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822,
	43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112,
	64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310,
	64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467,
	64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276,
	65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490,
	65495, 65498, 65500};
std::array<char32_t, 856> lexer::unicode_es5_identifier_part{
	170,   170,	  181,	 181,	186,   186,	  192,	 214,	216,   246,	  248,
	705,   710,	  721,	 736,	740,   748,	  748,	 750,	750,   768,	  884,
	886,   887,	  890,	 893,	902,   902,	  904,	 906,	908,   908,	  910,
	929,   931,	  1013,	 1015,	1153,  1155,  1159,	 1162,	1319,  1329,  1366,
	1369,  1369,  1377,	 1415,	1425,  1469,  1471,	 1471,	1473,  1474,  1476,
	1477,  1479,  1479,	 1488,	1514,  1520,  1522,	 1552,	1562,  1568,  1641,
	1646,  1747,  1749,	 1756,	1759,  1768,  1770,	 1788,	1791,  1791,  1808,
	1866,  1869,  1969,	 1984,	2037,  2042,  2042,	 2048,	2093,  2112,  2139,
	2208,  2208,  2210,	 2220,	2276,  2302,  2304,	 2403,	2406,  2415,  2417,
	2423,  2425,  2431,	 2433,	2435,  2437,  2444,	 2447,	2448,  2451,  2472,
	2474,  2480,  2482,	 2482,	2486,  2489,  2492,	 2500,	2503,  2504,  2507,
	2510,  2519,  2519,	 2524,	2525,  2527,  2531,	 2534,	2545,  2561,  2563,
	2565,  2570,  2575,	 2576,	2579,  2600,  2602,	 2608,	2610,  2611,  2613,
	2614,  2616,  2617,	 2620,	2620,  2622,  2626,	 2631,	2632,  2635,  2637,
	2641,  2641,  2649,	 2652,	2654,  2654,  2662,	 2677,	2689,  2691,  2693,
	2701,  2703,  2705,	 2707,	2728,  2730,  2736,	 2738,	2739,  2741,  2745,
	2748,  2757,  2759,	 2761,	2763,  2765,  2768,	 2768,	2784,  2787,  2790,
	2799,  2817,  2819,	 2821,	2828,  2831,  2832,	 2835,	2856,  2858,  2864,
	2866,  2867,  2869,	 2873,	2876,  2884,  2887,	 2888,	2891,  2893,  2902,
	2903,  2908,  2909,	 2911,	2915,  2918,  2927,	 2929,	2929,  2946,  2947,
	2949,  2954,  2958,	 2960,	2962,  2965,  2969,	 2970,	2972,  2972,  2974,
	2975,  2979,  2980,	 2984,	2986,  2990,  3001,	 3006,	3010,  3014,  3016,
	3018,  3021,  3024,	 3024,	3031,  3031,  3046,	 3055,	3073,  3075,  3077,
	3084,  3086,  3088,	 3090,	3112,  3114,  3123,	 3125,	3129,  3133,  3140,
	3142,  3144,  3146,	 3149,	3157,  3158,  3160,	 3161,	3168,  3171,  3174,
	3183,  3202,  3203,	 3205,	3212,  3214,  3216,	 3218,	3240,  3242,  3251,
	3253,  3257,  3260,	 3268,	3270,  3272,  3274,	 3277,	3285,  3286,  3294,
	3294,  3296,  3299,	 3302,	3311,  3313,  3314,	 3330,	3331,  3333,  3340,
	3342,  3344,  3346,	 3386,	3389,  3396,  3398,	 3400,	3402,  3406,  3415,
	3415,  3424,  3427,	 3430,	3439,  3450,  3455,	 3458,	3459,  3461,  3478,
	3482,  3505,  3507,	 3515,	3517,  3517,  3520,	 3526,	3530,  3530,  3535,
	3540,  3542,  3542,	 3544,	3551,  3570,  3571,	 3585,	3642,  3648,  3662,
	3664,  3673,  3713,	 3714,	3716,  3716,  3719,	 3720,	3722,  3722,  3725,
	3725,  3732,  3735,	 3737,	3743,  3745,  3747,	 3749,	3749,  3751,  3751,
	3754,  3755,  3757,	 3769,	3771,  3773,  3776,	 3780,	3782,  3782,  3784,
	3789,  3792,  3801,	 3804,	3807,  3840,  3840,	 3864,	3865,  3872,  3881,
	3893,  3893,  3895,	 3895,	3897,  3897,  3902,	 3911,	3913,  3948,  3953,
	3972,  3974,  3991,	 3993,	4028,  4038,  4038,	 4096,	4169,  4176,  4253,
	4256,  4293,  4295,	 4295,	4301,  4301,  4304,	 4346,	4348,  4680,  4682,
	4685,  4688,  4694,	 4696,	4696,  4698,  4701,	 4704,	4744,  4746,  4749,
	4752,  4784,  4786,	 4789,	4792,  4798,  4800,	 4800,	4802,  4805,  4808,
	4822,  4824,  4880,	 4882,	4885,  4888,  4954,	 4957,	4959,  4992,  5007,
	5024,  5108,  5121,	 5740,	5743,  5759,  5761,	 5786,	5792,  5866,  5870,
	5872,  5888,  5900,	 5902,	5908,  5920,  5940,	 5952,	5971,  5984,  5996,
	5998,  6000,  6002,	 6003,	6016,  6099,  6103,	 6103,	6108,  6109,  6112,
	6121,  6155,  6157,	 6160,	6169,  6176,  6263,	 6272,	6314,  6320,  6389,
	6400,  6428,  6432,	 6443,	6448,  6459,  6470,	 6509,	6512,  6516,  6528,
	6571,  6576,  6601,	 6608,	6617,  6656,  6683,	 6688,	6750,  6752,  6780,
	6783,  6793,  6800,	 6809,	6823,  6823,  6912,	 6987,	6992,  7001,  7019,
	7027,  7040,  7155,	 7168,	7223,  7232,  7241,	 7245,	7293,  7376,  7378,
	7380,  7414,  7424,	 7654,	7676,  7957,  7960,	 7965,	7968,  8005,  8008,
	8013,  8016,  8023,	 8025,	8025,  8027,  8027,	 8029,	8029,  8031,  8061,
	8064,  8116,  8118,	 8124,	8126,  8126,  8130,	 8132,	8134,  8140,  8144,
	8147,  8150,  8155,	 8160,	8172,  8178,  8180,	 8182,	8188,  8204,  8205,
	8255,  8256,  8276,	 8276,	8305,  8305,  8319,	 8319,	8336,  8348,  8400,
	8412,  8417,  8417,	 8421,	8432,  8450,  8450,	 8455,	8455,  8458,  8467,
	8469,  8469,  8473,	 8477,	8484,  8484,  8486,	 8486,	8488,  8488,  8490,
	8493,  8495,  8505,	 8508,	8511,  8517,  8521,	 8526,	8526,  8544,  8584,
	11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,
	11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,
	11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,
	11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,
	12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,
	12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,
	13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,
	42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,
	42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,
	43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,
	43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,
	43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,
	43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,
	43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,
	55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,
	64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,
	64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,
	65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,
	65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,
	65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500};
std::array<char32_t, 1218> lexer::unicode_esnext_identifier_start{
	65,		90,		97,		122,	170,	170,	181,	181,	186,
	186,	192,	214,	216,	246,	248,	705,	710,	721,
	736,	740,	748,	748,	750,	750,	880,	884,	886,
	887,	890,	893,	895,	895,	902,	902,	904,	906,
	908,	908,	910,	929,	931,	1013,	1015,	1153,	1162,
	1327,	1329,	1366,	1369,	1369,	1376,	1416,	1488,	1514,
	1519,	1522,	1568,	1610,	1646,	1647,	1649,	1747,	1749,
	1749,	1765,	1766,	1774,	1775,	1786,	1788,	1791,	1791,
	1808,	1808,	1810,	1839,	1869,	1957,	1969,	1969,	1994,
	2026,	2036,	2037,	2042,	2042,	2048,	2069,	2074,	2074,
	2084,	2084,	2088,	2088,	2112,	2136,	2144,	2154,	2208,
	2228,	2230,	2237,	2308,	2361,	2365,	2365,	2384,	2384,
	2392,	2401,	2417,	2432,	2437,	2444,	2447,	2448,	2451,
	2472,	2474,	2480,	2482,	2482,	2486,	2489,	2493,	2493,
	2510,	2510,	2524,	2525,	2527,	2529,	2544,	2545,	2556,
	2556,	2565,	2570,	2575,	2576,	2579,	2600,	2602,	2608,
	2610,	2611,	2613,	2614,	2616,	2617,	2649,	2652,	2654,
	2654,	2674,	2676,	2693,	2701,	2703,	2705,	2707,	2728,
	2730,	2736,	2738,	2739,	2741,	2745,	2749,	2749,	2768,
	2768,	2784,	2785,	2809,	2809,	2821,	2828,	2831,	2832,
	2835,	2856,	2858,	2864,	2866,	2867,	2869,	2873,	2877,
	2877,	2908,	2909,	2911,	2913,	2929,	2929,	2947,	2947,
	2949,	2954,	2958,	2960,	2962,	2965,	2969,	2970,	2972,
	2972,	2974,	2975,	2979,	2980,	2984,	2986,	2990,	3001,
	3024,	3024,	3077,	3084,	3086,	3088,	3090,	3112,	3114,
	3129,	3133,	3133,	3160,	3162,	3168,	3169,	3200,	3200,
	3205,	3212,	3214,	3216,	3218,	3240,	3242,	3251,	3253,
	3257,	3261,	3261,	3294,	3294,	3296,	3297,	3313,	3314,
	3333,	3340,	3342,	3344,	3346,	3386,	3389,	3389,	3406,
	3406,	3412,	3414,	3423,	3425,	3450,	3455,	3461,	3478,
	3482,	3505,	3507,	3515,	3517,	3517,	3520,	3526,	3585,
	3632,	3634,	3635,	3648,	3654,	3713,	3714,	3716,	3716,
	3718,	3722,	3724,	3747,	3749,	3749,	3751,	3760,	3762,
	3763,	3773,	3773,	3776,	3780,	3782,	3782,	3804,	3807,
	3840,	3840,	3904,	3911,	3913,	3948,	3976,	3980,	4096,
	4138,	4159,	4159,	4176,	4181,	4186,	4189,	4193,	4193,
	4197,	4198,	4206,	4208,	4213,	4225,	4238,	4238,	4256,
	4293,	4295,	4295,	4301,	4301,	4304,	4346,	4348,	4680,
	4682,	4685,	4688,	4694,	4696,	4696,	4698,	4701,	4704,
	4744,	4746,	4749,	4752,	4784,	4786,	4789,	4792,	4798,
	4800,	4800,	4802,	4805,	4808,	4822,	4824,	4880,	4882,
	4885,	4888,	4954,	4992,	5007,	5024,	5109,	5112,	5117,
	5121,	5740,	5743,	5759,	5761,	5786,	5792,	5866,	5870,
	5880,	5888,	5900,	5902,	5905,	5920,	5937,	5952,	5969,
	5984,	5996,	5998,	6000,	6016,	6067,	6103,	6103,	6108,
	6108,	6176,	6264,	6272,	6312,	6314,	6314,	6320,	6389,
	6400,	6430,	6480,	6509,	6512,	6516,	6528,	6571,	6576,
	6601,	6656,	6678,	6688,	6740,	6823,	6823,	6917,	6963,
	6981,	6987,	7043,	7072,	7086,	7087,	7098,	7141,	7168,
	7203,	7245,	7247,	7258,	7293,	7296,	7304,	7312,	7354,
	7357,	7359,	7401,	7404,	7406,	7411,	7413,	7414,	7418,
	7418,	7424,	7615,	7680,	7957,	7960,	7965,	7968,	8005,
	8008,	8013,	8016,	8023,	8025,	8025,	8027,	8027,	8029,
	8029,	8031,	8061,	8064,	8116,	8118,	8124,	8126,	8126,
	8130,	8132,	8134,	8140,	8144,	8147,	8150,	8155,	8160,
	8172,	8178,	8180,	8182,	8188,	8305,	8305,	8319,	8319,
	8336,	8348,	8450,	8450,	8455,	8455,	8458,	8467,	8469,
	8469,	8472,	8477,	8484,	8484,	8486,	8486,	8488,	8488,
	8490,	8505,	8508,	8511,	8517,	8521,	8526,	8526,	8544,
	8584,	11264,	11310,	11312,	11358,	11360,	11492,	11499,	11502,
	11506,	11507,	11520,	11557,	11559,	11559,	11565,	11565,	11568,
	11623,	11631,	11631,	11648,	11670,	11680,	11686,	11688,	11694,
	11696,	11702,	11704,	11710,	11712,	11718,	11720,	11726,	11728,
	11734,	11736,	11742,	12293,	12295,	12321,	12329,	12337,	12341,
	12344,	12348,	12353,	12438,	12443,	12447,	12449,	12538,	12540,
	12543,	12549,	12591,	12593,	12686,	12704,	12730,	12784,	12799,
	13312,	19893,	19968,	40943,	40960,	42124,	42192,	42237,	42240,
	42508,	42512,	42527,	42538,	42539,	42560,	42606,	42623,	42653,
	42656,	42735,	42775,	42783,	42786,	42888,	42891,	42943,	42946,
	42950,	42999,	43009,	43011,	43013,	43015,	43018,	43020,	43042,
	43072,	43123,	43138,	43187,	43250,	43255,	43259,	43259,	43261,
	43262,	43274,	43301,	43312,	43334,	43360,	43388,	43396,	43442,
	43471,	43471,	43488,	43492,	43494,	43503,	43514,	43518,	43520,
	43560,	43584,	43586,	43588,	43595,	43616,	43638,	43642,	43642,
	43646,	43695,	43697,	43697,	43701,	43702,	43705,	43709,	43712,
	43712,	43714,	43714,	43739,	43741,	43744,	43754,	43762,	43764,
	43777,	43782,	43785,	43790,	43793,	43798,	43808,	43814,	43816,
	43822,	43824,	43866,	43868,	43879,	43888,	44002,	44032,	55203,
	55216,	55238,	55243,	55291,	63744,	64109,	64112,	64217,	64256,
	64262,	64275,	64279,	64285,	64285,	64287,	64296,	64298,	64310,
	64312,	64316,	64318,	64318,	64320,	64321,	64323,	64324,	64326,
	64433,	64467,	64829,	64848,	64911,	64914,	64967,	65008,	65019,
	65136,	65140,	65142,	65276,	65313,	65338,	65345,	65370,	65382,
	65470,	65474,	65479,	65482,	65487,	65490,	65495,	65498,	65500,
	65536,	65547,	65549,	65574,	65576,	65594,	65596,	65597,	65599,
	65613,	65616,	65629,	65664,	65786,	65856,	65908,	66176,	66204,
	66208,	66256,	66304,	66335,	66349,	66378,	66384,	66421,	66432,
	66461,	66464,	66499,	66504,	66511,	66513,	66517,	66560,	66717,
	66736,	66771,	66776,	66811,	66816,	66855,	66864,	66915,	67072,
	67382,	67392,	67413,	67424,	67431,	67584,	67589,	67592,	67592,
	67594,	67637,	67639,	67640,	67644,	67644,	67647,	67669,	67680,
	67702,	67712,	67742,	67808,	67826,	67828,	67829,	67840,	67861,
	67872,	67897,	67968,	68023,	68030,	68031,	68096,	68096,	68112,
	68115,	68117,	68119,	68121,	68149,	68192,	68220,	68224,	68252,
	68288,	68295,	68297,	68324,	68352,	68405,	68416,	68437,	68448,
	68466,	68480,	68497,	68608,	68680,	68736,	68786,	68800,	68850,
	68864,	68899,	69376,	69404,	69415,	69415,	69424,	69445,	69600,
	69622,	69635,	69687,	69763,	69807,	69840,	69864,	69891,	69926,
	69956,	69956,	69968,	70002,	70006,	70006,	70019,	70066,	70081,
	70084,	70106,	70106,	70108,	70108,	70144,	70161,	70163,	70187,
	70272,	70278,	70280,	70280,	70282,	70285,	70287,	70301,	70303,
	70312,	70320,	70366,	70405,	70412,	70415,	70416,	70419,	70440,
	70442,	70448,	70450,	70451,	70453,	70457,	70461,	70461,	70480,
	70480,	70493,	70497,	70656,	70708,	70727,	70730,	70751,	70751,
	70784,	70831,	70852,	70853,	70855,	70855,	71040,	71086,	71128,
	71131,	71168,	71215,	71236,	71236,	71296,	71338,	71352,	71352,
	71424,	71450,	71680,	71723,	71840,	71903,	71935,	71935,	72096,
	72103,	72106,	72144,	72161,	72161,	72163,	72163,	72192,	72192,
	72203,	72242,	72250,	72250,	72272,	72272,	72284,	72329,	72349,
	72349,	72384,	72440,	72704,	72712,	72714,	72750,	72768,	72768,
	72818,	72847,	72960,	72966,	72968,	72969,	72971,	73008,	73030,
	73030,	73056,	73061,	73063,	73064,	73066,	73097,	73112,	73112,
	73440,	73458,	73728,	74649,	74752,	74862,	74880,	75075,	77824,
	78894,	82944,	83526,	92160,	92728,	92736,	92766,	92880,	92909,
	92928,	92975,	92992,	92995,	93027,	93047,	93053,	93071,	93760,
	93823,	93952,	94026,	94032,	94032,	94099,	94111,	94176,	94177,
	94179,	94179,	94208,	100343, 100352, 101106, 110592, 110878, 110928,
	110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788,
	113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966,
	119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993,
	119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077,
	120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132,
	120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514,
	120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654,
	120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772,
	120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627,
	124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469,
	126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514,
	126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535,
	126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546,
	126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557,
	126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570,
	126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592,
	126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651,
	131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984,
	191456, 194560, 195101};
std::array<char32_t, 1426> lexer::unicode_esnext_identifier_part{
	48,		57,		65,		90,		95,		95,		97,		122,	170,
	170,	181,	181,	183,	183,	186,	186,	192,	214,
	216,	246,	248,	705,	710,	721,	736,	740,	748,
	748,	750,	750,	768,	884,	886,	887,	890,	893,
	895,	895,	902,	906,	908,	908,	910,	929,	931,
	1013,	1015,	1153,	1155,	1159,	1162,	1327,	1329,	1366,
	1369,	1369,	1376,	1416,	1425,	1469,	1471,	1471,	1473,
	1474,	1476,	1477,	1479,	1479,	1488,	1514,	1519,	1522,
	1552,	1562,	1568,	1641,	1646,	1747,	1749,	1756,	1759,
	1768,	1770,	1788,	1791,	1791,	1808,	1866,	1869,	1969,
	1984,	2037,	2042,	2042,	2045,	2045,	2048,	2093,	2112,
	2139,	2144,	2154,	2208,	2228,	2230,	2237,	2259,	2273,
	2275,	2403,	2406,	2415,	2417,	2435,	2437,	2444,	2447,
	2448,	2451,	2472,	2474,	2480,	2482,	2482,	2486,	2489,
	2492,	2500,	2503,	2504,	2507,	2510,	2519,	2519,	2524,
	2525,	2527,	2531,	2534,	2545,	2556,	2556,	2558,	2558,
	2561,	2563,	2565,	2570,	2575,	2576,	2579,	2600,	2602,
	2608,	2610,	2611,	2613,	2614,	2616,	2617,	2620,	2620,
	2622,	2626,	2631,	2632,	2635,	2637,	2641,	2641,	2649,
	2652,	2654,	2654,	2662,	2677,	2689,	2691,	2693,	2701,
	2703,	2705,	2707,	2728,	2730,	2736,	2738,	2739,	2741,
	2745,	2748,	2757,	2759,	2761,	2763,	2765,	2768,	2768,
	2784,	2787,	2790,	2799,	2809,	2815,	2817,	2819,	2821,
	2828,	2831,	2832,	2835,	2856,	2858,	2864,	2866,	2867,
	2869,	2873,	2876,	2884,	2887,	2888,	2891,	2893,	2902,
	2903,	2908,	2909,	2911,	2915,	2918,	2927,	2929,	2929,
	2946,	2947,	2949,	2954,	2958,	2960,	2962,	2965,	2969,
	2970,	2972,	2972,	2974,	2975,	2979,	2980,	2984,	2986,
	2990,	3001,	3006,	3010,	3014,	3016,	3018,	3021,	3024,
	3024,	3031,	3031,	3046,	3055,	3072,	3084,	3086,	3088,
	3090,	3112,	3114,	3129,	3133,	3140,	3142,	3144,	3146,
	3149,	3157,	3158,	3160,	3162,	3168,	3171,	3174,	3183,
	3200,	3203,	3205,	3212,	3214,	3216,	3218,	3240,	3242,
	3251,	3253,	3257,	3260,	3268,	3270,	3272,	3274,	3277,
	3285,	3286,	3294,	3294,	3296,	3299,	3302,	3311,	3313,
	3314,	3328,	3331,	3333,	3340,	3342,	3344,	3346,	3396,
	3398,	3400,	3402,	3406,	3412,	3415,	3423,	3427,	3430,
	3439,	3450,	3455,	3458,	3459,	3461,	3478,	3482,	3505,
	3507,	3515,	3517,	3517,	3520,	3526,	3530,	3530,	3535,
	3540,	3542,	3542,	3544,	3551,	3558,	3567,	3570,	3571,
	3585,	3642,	3648,	3662,	3664,	3673,	3713,	3714,	3716,
	3716,	3718,	3722,	3724,	3747,	3749,	3749,	3751,	3773,
	3776,	3780,	3782,	3782,	3784,	3789,	3792,	3801,	3804,
	3807,	3840,	3840,	3864,	3865,	3872,	3881,	3893,	3893,
	3895,	3895,	3897,	3897,	3902,	3911,	3913,	3948,	3953,
	3972,	3974,	3991,	3993,	4028,	4038,	4038,	4096,	4169,
	4176,	4253,	4256,	4293,	4295,	4295,	4301,	4301,	4304,
	4346,	4348,	4680,	4682,	4685,	4688,	4694,	4696,	4696,
	4698,	4701,	4704,	4744,	4746,	4749,	4752,	4784,	4786,
	4789,	4792,	4798,	4800,	4800,	4802,	4805,	4808,	4822,
	4824,	4880,	4882,	4885,	4888,	4954,	4957,	4959,	4969,
	4977,	4992,	5007,	5024,	5109,	5112,	5117,	5121,	5740,
	5743,	5759,	5761,	5786,	5792,	5866,	5870,	5880,	5888,
	5900,	5902,	5908,	5920,	5940,	5952,	5971,	5984,	5996,
	5998,	6000,	6002,	6003,	6016,	6099,	6103,	6103,	6108,
	6109,	6112,	6121,	6155,	6157,	6160,	6169,	6176,	6264,
	6272,	6314,	6320,	6389,	6400,	6430,	6432,	6443,	6448,
	6459,	6470,	6509,	6512,	6516,	6528,	6571,	6576,	6601,
	6608,	6618,	6656,	6683,	6688,	6750,	6752,	6780,	6783,
	6793,	6800,	6809,	6823,	6823,	6832,	6845,	6912,	6987,
	6992,	7001,	7019,	7027,	7040,	7155,	7168,	7223,	7232,
	7241,	7245,	7293,	7296,	7304,	7312,	7354,	7357,	7359,
	7376,	7378,	7380,	7418,	7424,	7673,	7675,	7957,	7960,
	7965,	7968,	8005,	8008,	8013,	8016,	8023,	8025,	8025,
	8027,	8027,	8029,	8029,	8031,	8061,	8064,	8116,	8118,
	8124,	8126,	8126,	8130,	8132,	8134,	8140,	8144,	8147,
	8150,	8155,	8160,	8172,	8178,	8180,	8182,	8188,	8255,
	8256,	8276,	8276,	8305,	8305,	8319,	8319,	8336,	8348,
	8400,	8412,	8417,	8417,	8421,	8432,	8450,	8450,	8455,
	8455,	8458,	8467,	8469,	8469,	8472,	8477,	8484,	8484,
	8486,	8486,	8488,	8488,	8490,	8505,	8508,	8511,	8517,
	8521,	8526,	8526,	8544,	8584,	11264,	11310,	11312,	11358,
	11360,	11492,	11499,	11507,	11520,	11557,	11559,	11559,	11565,
	11565,	11568,	11623,	11631,	11631,	11647,	11670,	11680,	11686,
	11688,	11694,	11696,	11702,	11704,	11710,	11712,	11718,	11720,
	11726,	11728,	11734,	11736,	11742,	11744,	11775,	12293,	12295,
	12321,	12335,	12337,	12341,	12344,	12348,	12353,	12438,	12441,
	12447,	12449,	12538,	12540,	12543,	12549,	12591,	12593,	12686,
	12704,	12730,	12784,	12799,	13312,	19893,	19968,	40943,	40960,
	42124,	42192,	42237,	42240,	42508,	42512,	42539,	42560,	42607,
	42612,	42621,	42623,	42737,	42775,	42783,	42786,	42888,	42891,
	42943,	42946,	42950,	42999,	43047,	43072,	43123,	43136,	43205,
	43216,	43225,	43232,	43255,	43259,	43259,	43261,	43309,	43312,
	43347,	43360,	43388,	43392,	43456,	43471,	43481,	43488,	43518,
	43520,	43574,	43584,	43597,	43600,	43609,	43616,	43638,	43642,
	43714,	43739,	43741,	43744,	43759,	43762,	43766,	43777,	43782,
	43785,	43790,	43793,	43798,	43808,	43814,	43816,	43822,	43824,
	43866,	43868,	43879,	43888,	44010,	44012,	44013,	44016,	44025,
	44032,	55203,	55216,	55238,	55243,	55291,	63744,	64109,	64112,
	64217,	64256,	64262,	64275,	64279,	64285,	64296,	64298,	64310,
	64312,	64316,	64318,	64318,	64320,	64321,	64323,	64324,	64326,
	64433,	64467,	64829,	64848,	64911,	64914,	64967,	65008,	65019,
	65024,	65039,	65056,	65071,	65075,	65076,	65101,	65103,	65136,
	65140,	65142,	65276,	65296,	65305,	65313,	65338,	65343,	65343,
	65345,	65370,	65382,	65470,	65474,	65479,	65482,	65487,	65490,
	65495,	65498,	65500,	65536,	65547,	65549,	65574,	65576,	65594,
	65596,	65597,	65599,	65613,	65616,	65629,	65664,	65786,	65856,
	65908,	66045,	66045,	66176,	66204,	66208,	66256,	66272,	66272,
	66304,	66335,	66349,	66378,	66384,	66426,	66432,	66461,	66464,
	66499,	66504,	66511,	66513,	66517,	66560,	66717,	66720,	66729,
	66736,	66771,	66776,	66811,	66816,	66855,	66864,	66915,	67072,
	67382,	67392,	67413,	67424,	67431,	67584,	67589,	67592,	67592,
	67594,	67637,	67639,	67640,	67644,	67644,	67647,	67669,	67680,
	67702,	67712,	67742,	67808,	67826,	67828,	67829,	67840,	67861,
	67872,	67897,	67968,	68023,	68030,	68031,	68096,	68099,	68101,
	68102,	68108,	68115,	68117,	68119,	68121,	68149,	68152,	68154,
	68159,	68159,	68192,	68220,	68224,	68252,	68288,	68295,	68297,
	68326,	68352,	68405,	68416,	68437,	68448,	68466,	68480,	68497,
	68608,	68680,	68736,	68786,	68800,	68850,	68864,	68903,	68912,
	68921,	69376,	69404,	69415,	69415,	69424,	69456,	69600,	69622,
	69632,	69702,	69734,	69743,	69759,	69818,	69840,	69864,	69872,
	69881,	69888,	69940,	69942,	69951,	69956,	69958,	69968,	70003,
	70006,	70006,	70016,	70084,	70089,	70092,	70096,	70106,	70108,
	70108,	70144,	70161,	70163,	70199,	70206,	70206,	70272,	70278,
	70280,	70280,	70282,	70285,	70287,	70301,	70303,	70312,	70320,
	70378,	70384,	70393,	70400,	70403,	70405,	70412,	70415,	70416,
	70419,	70440,	70442,	70448,	70450,	70451,	70453,	70457,	70459,
	70468,	70471,	70472,	70475,	70477,	70480,	70480,	70487,	70487,
	70493,	70499,	70502,	70508,	70512,	70516,	70656,	70730,	70736,
	70745,	70750,	70751,	70784,	70853,	70855,	70855,	70864,	70873,
	71040,	71093,	71096,	71104,	71128,	71133,	71168,	71232,	71236,
	71236,	71248,	71257,	71296,	71352,	71360,	71369,	71424,	71450,
	71453,	71467,	71472,	71481,	71680,	71738,	71840,	71913,	71935,
	71935,	72096,	72103,	72106,	72151,	72154,	72161,	72163,	72164,
	72192,	72254,	72263,	72263,	72272,	72345,	72349,	72349,	72384,
	72440,	72704,	72712,	72714,	72758,	72760,	72768,	72784,	72793,
	72818,	72847,	72850,	72871,	72873,	72886,	72960,	72966,	72968,
	72969,	72971,	73014,	73018,	73018,	73020,	73021,	73023,	73031,
	73040,	73049,	73056,	73061,	73063,	73064,	73066,	73102,	73104,
	73105,	73107,	73112,	73120,	73129,	73440,	73462,	73728,	74649,
	74752,	74862,	74880,	75075,	77824,	78894,	82944,	83526,	92160,
	92728,	92736,	92766,	92768,	92777,	92880,	92909,	92912,	92916,
	92928,	92982,	92992,	92995,	93008,	93017,	93027,	93047,	93053,
	93071,	93760,	93823,	93952,	94026,	94031,	94087,	94095,	94111,
	94176,	94177,	94179,	94179,	94208,	100343, 100352, 101106, 110592,
	110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770,
	113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141,
	119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213,
	119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970,
	119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995,
	119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086,
	120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134,
	120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540,
	120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,
	120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782,
	120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476,
	121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907,
	122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197,
	123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136,
	125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495,
	126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516,
	126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535,
	126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548,
	126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557,
	126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572,
	126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601,
	126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072,
	173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456,
	194560, 195101, 917760, 917999};

lex_error::lex_error(const source_location& location) noexcept
	: location_(location) {}

const source_location& lex_error::location() const noexcept {
	return location_;
}

lexer::iterator::value_type& lexer::iterator::operator*() const {
	return *token_;
}

lexer::iterator::pointer_type lexer::iterator::operator->() const {
	return token_.get();
}

lexer::iterator& lexer::iterator::operator++() {
	if (token_.use_count() > 1)
		token_ = std::make_shared<token>();

	if (!lexer_->scan(*token_))
		token_->undefine();
	return *this;
}

lexer::iterator lexer::iterator::operator++(int) {
	auto cp = *this;
	++(*this);
	return cp;
}

bool lexer::iterator::operator==(const iterator& other) const {
	return (token_ == other.token_) || (*token_ == *other.token_);
}

bool lexer::iterator::operator!=(const iterator& other) const {
	return !operator==(other);
}

lexer::iterator::iterator(lexer* source)
	: token_(std::make_shared<token>()), lexer_(source) {}

lexer::lexer(std::istream& stream,
			 std::shared_ptr<source> stream_metadata,
			 language_version version)
	: stream_(stream),
	  source_(std::move(stream_metadata)),
	  buffer_offset_(0),
	  end_(this),
	  pnewline_(false),
	  vers_(version) {
	wbuffer_.reserve(buffer_size);
}

lexer::iterator lexer::begin() {
	lexer::iterator result(this);
	++result;
	return result;
}

lexer::iterator lexer::end() {
	return end_;
}

std::unordered_map<std::u32string, lexer::tokfactory>
	lexer::
		keyword_lookup{{U"abstract",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::abstract_token>(
								location);
						}},
					   {U"accessor",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::accessor_token>(
								location);
						}},
					   {U"any",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::any_token>(location);
						}},
					   {U"as",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::as_token>(location);
						}},
					   {U"asserts",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::asserts_token>(location);
						}},
					   {U"assert",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::assert_token>(location);
						}},
					   {U"async",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::async_token>(location);
						}},
					   {U"await",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::await_token>(location);
						}},
					   {U"bigint",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::bigint_token>(location);
						}},
					   {U"boolean",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::boolean_token>(location);
						}},
					   {U"break",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::break_token>(location);
						}},
					   {U"case",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::case_token>(location);
						}},
					   {U"catch",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::catch_token>(location);
						}},
					   {U"class",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::class_token>(location);
						}},
					   {U"continue",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::continue_token>(
								location);
						}},
					   {U"const",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::const_token>(location);
						}},
					   {U"constructor",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::constructor_token>(
								location);
						}},
					   {U"debugger",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::debugger_token>(
								location);
						}},
					   {U"declare",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::declare_token>(location);
						}},
					   {U"default",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::default_token>(location);
						}},
					   {U"delete",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::delete_token>(location);
						}},
					   {U"do",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::do_token>(location);
						}},
					   {U"else",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::else_token>(location);
						}},
					   {U"export",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::export_token>(location);
						}},
					   {U"extends",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::extends_token>(location);
						}},
					   {U"false",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::false_token>(location);
						}},
					   {U"finally",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::finally_token>(location);
						}},
					   {U"for",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::for_token>(location);
						}},
					   {U"from",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::from_token>(location);
						}},
					   {U"function",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::function_token>(
								location);
						}},
					   {U"get",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::get_token>(location);
						}},
					   {U"global",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::global_token>(location);
						}},
					   {U"if",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::if_token>(location);
						}},
					   {U"implements",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::implements_token>(
								location);
						}},
					   {U"import",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::import_token>(location);
						}},
					   {U"in",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::in_token>(location);
						}},
					   {U"infer",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::infer_token>(location);
						}},
					   {U"instanceof",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::instanceof_token>(
								location);
						}},
					   {U"interface",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::interface_token>(
								location);
						}},
					   {U"intrinsic",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::intrinsic_token>(
								location);
						}},
					   {U"is",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::is_token>(location);
						}},
					   {U"keyof",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::keyof_token>(location);
						}},
					   {U"let",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::let_token>(location);
						}},
					   {U"module",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::module_token>(location);
						}},
					   {U"namespace",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::namespace_token>(
								location);
						}},
					   {U"never",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::never_token>(location);
						}},
					   {U"new",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::new_token>(location);
						}},
					   {U"null",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::null_token>(location);
						}},
					   {U"number",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::number_token>(location);
						}},
					   {U"of",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::of_token>(location);
						}},
					   {U"object",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::object_token>(location);
						}},
					   {U"package",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::package_token>(location);
						}},
					   {U"private",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::private_token>(location);
						}},
					   {U"protected",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::protected_token>(
								location);
						}},
					   {U"public",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::public_token>(location);
						}},
					   {U"override",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::override_token>(
								location);
						}},
					   {U"out",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::out_token>(location);
						}},
					   {U"readonly",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::readonly_token>(
								location);
						}},
					   {U"require",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::require_token>(location);
						}},
					   {U"return",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::return_token>(location);
						}},
					   {U"satisfies",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::satisfies_token>(
								location);
						}},
					   {U"set",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::set_token>(location);
						}},
					   {U"static",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::static_token>(location);
						}},
					   {U"string",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::string_token>(location);
						}},
					   {U"super",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::super_token>(location);
						}},
					   {U"switch",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::switch_token>(location);
						}},
					   {U"symbol",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::symbol_token>(location);
						}},
					   {U"this",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::this_token>(location);
						}},
					   {U"throw",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::throw_token>(location);
						}},
					   {U"true",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::true_token>(location);
						}},
					   {U"try",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::try_token>(location);
						}},
					   {U"type",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::type_token>(location);
						}},
					   {U"typeof",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::typeof_token>(location);
						}},
					   {U"undefined",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::undefined_token>(
								location);
						}},
					   {U"unique",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::unique_token>(location);
						}},
					   {U"unknown",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::unknown_token>(location);
						}},
					   {U"var",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::var_token>(location);
						}},
					   {U"void",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::void_token>(location);
						}},
					   {U"while",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::while_token>(location);
						}},
					   {U"with",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::with_token>(location);
						}},
					   {U"yield",
						[](token& into, const source_location& location) {
							into.emplace_token<tokens::yield_token>(location);
						}}};

inline std::size_t lexer::next_code_point(char32_t& into,
										  std::size_t look_forward) {
	auto read_more = [this](std::size_t needed) -> std::size_t {
		if (stream_.eof())
			return 0;

		auto sn = needed;
		while (true) {
			auto preserve_size = rbuffer_.size() - buffer_offset_;
			memmove(rbuffer_.data(), rbuffer_.data() + buffer_offset_,
					preserve_size);
			buffer_offset_ = 0;

			rbuffer_.resize(buffer_size);
			auto read = stream_.readsome(
				rbuffer_.data() + preserve_size,
				static_cast<std::streamsize>(buffer_size - preserve_size));

			if (read <= 0) {
				rbuffer_.resize(preserve_size);
				return sn - needed;
			}

			rbuffer_.resize(buffer_offset_ + read);
			needed -= std::min(needed, static_cast<std::size_t>(read));

			if (!needed)
				return sn;
		}
	};

	if ((buffer_offset_ + look_forward) >= rbuffer_.size()) {
		if (!read_more(1))
			return 0;
	}

	// get one character
	auto chr0 =
		static_cast<unsigned char>(rbuffer_[buffer_offset_ + look_forward]);
	// if the value is either below 0x7f or isn't a valid utf-8 codepoint
	if (chr0 <= 0x7f || (chr0 & 0xc0) != 0xc0) {
		into = chr0;
		return 1;
	}

	if ((chr0 & 0xe0) == 0xc0) {
		// 2 characters -> 11 bits
		if ((buffer_offset_ + look_forward + 1) >= rbuffer_.size() &&
			read_more(1) < 1) {
			into = chr0;
			return 1;
		}

		auto chr1 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 1]);
		if ((chr1 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		into = (static_cast<char32_t>(chr0 & 0x1f) << 6) |
			   static_cast<char32_t>(chr1 & 0x3f);
		return 2;
	}

	if ((chr0 & 0xf0) == 0xe0) {
		// 3 characters -> 16 bits
		if ((buffer_offset_ + look_forward + 2) >= rbuffer_.size() &&
			read_more(2) < 2) {
			into = chr0;
			return 1;
		}

		auto chr1 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 1]);
		if ((chr1 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr2 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 2]);
		if ((chr2 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		into = (static_cast<char32_t>(chr0 & 0x0f) << 12) |
			   (static_cast<char32_t>(chr1 & 0x3f) << 6) |
			   static_cast<char32_t>(chr2 & 0x3f);
		return 3;
	}

	if ((chr0 & 0xf8) == 0xf0) {
		// 4 characters -> 21 bits
		if ((buffer_offset_ + look_forward + 3) >= rbuffer_.size() &&
			read_more(3) < 3) {
			into = chr0;
			return 1;
		}

		auto chr1 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 1]);
		if ((chr1 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr2 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 2]);
		if ((chr2 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr3 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 3]);
		if ((chr3 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		into = (static_cast<char32_t>(chr0 & 0x07) << 18) |
			   (static_cast<char32_t>(chr1 & 0x3f) << 12) |
			   (static_cast<char32_t>(chr2 & 0x3f) << 6) |
			   static_cast<char32_t>(chr3 & 0x3f);
		return 4;
	}

	if ((chr0 & 0xfc) == 0xf8) {
		// 5 characters -> 26 bits
		if ((buffer_offset_ + look_forward + 4) >= rbuffer_.size() &&
			read_more(4) < 4) {
			into = chr0;
			return 1;
		}

		auto chr1 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 1]);
		if ((chr1 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr2 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 2]);
		if ((chr2 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr3 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 3]);
		if ((chr3 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr4 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 4]);
		if ((chr4 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		into = (static_cast<char32_t>(chr0 & 0x03) << 24) |
			   (static_cast<char32_t>(chr1 & 0x3f) << 18) |
			   (static_cast<char32_t>(chr2 & 0x3f) << 12) |
			   (static_cast<char32_t>(chr3 & 0x3f) << 6) |
			   static_cast<char32_t>(chr4 & 0x3f);
		return 5;
	}

	if ((chr0 & 0xfe) == 0xfc) {
		// 6 characters -> 31 bits
		if ((buffer_offset_ + look_forward + 5) >= rbuffer_.size() &&
			read_more(5) < 5) {
			into = chr0;
			return 1;
		}

		auto chr1 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 1]);
		if ((chr1 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr2 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 2]);
		if ((chr2 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr3 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 3]);
		if ((chr3 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr4 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 4]);
		if ((chr4 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		auto chr5 = static_cast<unsigned char>(
			rbuffer_[buffer_offset_ + look_forward + 5]);
		if ((chr5 & 0xc0) != 0x80) {
			into = chr0;
			return 1;
		}

		into = (static_cast<char32_t>(chr0 & 0x01) << 30) |
			   (static_cast<char32_t>(chr1 & 0x3f) << 24) |
			   (static_cast<char32_t>(chr2 & 0x3f) << 18) |
			   (static_cast<char32_t>(chr3 & 0x3f) << 12) |
			   (static_cast<char32_t>(chr4 & 0x3f) << 6) |
			   static_cast<char32_t>(chr5 & 0x3f);
		return 6;
	}

	return chr0;
}

void lexer::scan_shebang(std::size_t shebang_offset, token& into) {
	auto shebang_location = location();
	advance(shebang_offset);

	scan_line_into_wbuffer();

	if (wbuffer_.empty())
		throw expected_command(shebang_location);

	into.emplace_token<tokens::shebang_token>(shebang_location, wbuffer_);
}

void lexer::scan_string(token& into) {
	auto string_location = location();

	char32_t quote_end;
	char32_t first{};

	advance(next_code_point(quote_end));
	wbuffer_.clear();

	// read the command until a eof or an eol
	while (true) {
		auto nc = next_code_point(first);
		if (!nc) {
			throw unterminated_string_literal(string_location);
		}

		advance(nc);
		if (first == quote_end) {
			break;
		}

		switch (first) {
			case '\r':
			case '\n':
				throw unterminated_string_literal(string_location);
			case '\\': {
				char32_t second{};
				auto nnc = next_code_point(second);
				if (nnc) {
					if (second == '\r') {
						char32_t third{};
						auto nnnc = next_code_point(third);
						if (nc && third == '\n') {
							advance(nnc + nnnc);
							gpos_.advance_line();
							goto scan_next_char;
						}

						advance(nc + nnc);
						goto scan_next_char;
					}

					if (second == '\n') {
						advance(nnc);
						gpos_.advance_line();
						goto scan_next_char;
					}
				}

				advance(scan_escape_sequence(first));
			}
		}

		append_wbuffer(first);
	scan_next_char:
	}

	into.emplace_token<tokens::constant_value_token>(
		string_location, wbuffer_, static_cast<char>(quote_end));
}

std::size_t lexer::scan_escape_sequence(char32_t& into, std::size_t skip) {
	auto gc = next_code_point(into, skip);
	if (!gc)
		return 0;

	if (into == 'u' || into == 'U') {
		bool is_curly_braced = false;
		char32_t check_curly;
		auto cc = next_code_point(check_curly, skip + gc);
		if (cc && check_curly == '{') {
			gc += cc;
			is_curly_braced = true;
		}

		long long ucfirst;
		auto scanned = scan_hex_number(ucfirst, is_curly_braced ? 1 : 4,
									   is_curly_braced, false, gc + skip);

		if (!scanned) {
			return gc - is_curly_braced ? cc : 0;
		}

		if (is_curly_braced) {
			cc = next_code_point(check_curly, skip + gc + scanned);
			if (!cc) {
				throw unexpected_end_of_text(location() + gc);
			}

			if (check_curly != '}') {
				throw unterminated_unicode_escape_sequence(location() + gc);
			}

			// Validate the Unicode code point
			if (ucfirst > 0x10FFFF) {
				throw unicode_value_out_of_range(location());
			}

			into = ucfirst;
			return gc + scanned + cc;
		}

		// Validate the Unicode code point
		if (ucfirst > 0xFFFF) {
			throw unicode_value_out_of_range(location());
		}

		if ((ucfirst >> 11) != 0x1b) {
			into = ucfirst;
			return gc + scanned;
		}

		char32_t next;
		auto nnc = next_code_point(next, gc + skip + scanned);
		if (!nnc || next != '\\') {
			into = ucfirst;
			return gc + scanned;
		}

		char32_t checku;
		auto checkuc = next_code_point(checku, gc + skip + scanned + nnc);
		if (!checkuc || (checku != 'u' && checku != 'U')) {
			into = ucfirst;
			return gc + scanned;
		}

		try {
			long long ucsecond;
			auto nscanned = scan_hex_number(
				ucsecond, 4, false, false, gc + skip + scanned + nnc + checkuc);
			if (ucsecond <= 0xFFFF && nscanned && (ucsecond >> 10) == 0x37) {
				into =
					(((ucfirst & 0x3ff) << 10) | (ucsecond & 0x3ff)) + 0x10000;
				return gc + scanned + nnc + checkuc + nscanned;
			}
		} catch (...) {
			// ignore errors in the subsequent section at this scope
		}

		into = ucfirst;
		return gc + scanned;
	}

	if (into == 'x' || into == 'X') {
		// handle 1 byte hex identifier
		long long hexfirst;
		auto scanned = scan_hex_number(hexfirst, 2, false, false, gc + skip);

		if (!scanned || hexfirst > 0xFF) {
			return gc + skip;
		}

		into = hexfirst;
		return scanned;
	}

	if (into == '0') {
		// handle either octal or binary
		char32_t next;
		auto nnc = next_code_point(next, gc + skip);
		if (nnc == 'b' || nnc == 'B') {
			long long number;
			auto scanned = scan_binary_number(number, gc + nnc + skip);
			if (scanned && number < 0x7f000000ul) {
				into = static_cast<char32_t>(number);
				return scanned;
			}

			return gc + skip;
		}

		long long number;
		auto scanned = scan_octal_number(number, false, gc + skip);
		if (scanned && number < 0x7f000000ul) {
			into = static_cast<char32_t>(number);
			return scanned;
		}

		return gc + skip;
	}

	if (is_octal_digit(into)) {
		long long number;
		auto scanned = scan_octal_number(number, false, gc + skip);
		if (scanned && number < 0x7f000000ul) {
			into = static_cast<char32_t>(number);
			return scanned;
		}

		return gc + skip;
	}

	switch (into) {
		case 'b':
			into = '\b';
			break;
		case 'f':
			into = '\f';
			break;
		case 'n':
			into = '\n';
			break;
		case 'r':
			into = '\r';
			break;
		case 't':
			into = '\t';
			break;
		case 'v':
			into = '\v';
			break;
		default:
			break;
	}

	return gc + skip;
}

void lexer::scan_string_template(token& into) {
	throw std::system_error(std::make_error_code(std::errc::not_supported));
}

void lexer::scan_line_comment(std::size_t comment_offset, token& into) {
	auto comment_location = location();
	advance(comment_offset);

	scan_line_into_wbuffer();

	into.emplace_token<tokens::comment_token>(comment_location,
											  std::move(wbuffer_));
}

void lexer::scan_multiline_comment(token& into, bool is_jsdoc) {
	auto comment_location = location();

	std::size_t multiline_index = 0;
	if (multiline_buffer_.size() < 1) {
		multiline_buffer_.resize(1);
	}

	char32_t first{};
	while (true) {
		auto nc = next_code_point(first);
		if (!nc) {
			throw unterminated_multiline_comment(comment_location);
		}

		advance(nc);
		if (first == '\n') {
			// trim any whitespace off of the end
			std::size_t end = wbuffer_.size();
			while (std::iswspace(wbuffer_[end - 1])) {
				end--;
			}

			wbuffer_.erase(end);
			gpos_.advance_line();

			if (multiline_buffer_.size() == multiline_index) {
				std::size_t new_size = multiline_buffer_.size() >= 1024
										   ? multiline_buffer_.size() + 1024
										   : multiline_buffer_.size() * 2;
				multiline_buffer_.resize(new_size);
			}
			multiline_buffer_[multiline_index++].assign(wbuffer_);
			wbuffer_.clear();
			continue;
		}

		if (first == '*') {
			char32_t second{};
			auto nnc = next_code_point(second);
			if (nnc && second == '/') {
				advance(nnc);
				break;
			}
		}

		append_wbuffer(first);
	}

	if (!wbuffer_.empty()) {
		if (multiline_buffer_.size() == multiline_index) {
			std::size_t new_size = multiline_buffer_.size() >= 1024
									   ? multiline_buffer_.size() + 1024
									   : multiline_buffer_.size() * 2;
			multiline_buffer_.resize(new_size);
		}

		multiline_buffer_[multiline_index++].assign(wbuffer_);
		wbuffer_.clear();
	}

	if (is_jsdoc) {
		into.emplace_token<tokens::jsdoc_token>(
			comment_location,
			std::span(multiline_buffer_.begin(), multiline_index));
		return;
	}

	into.emplace_token<tokens::multiline_comment_token>(
		comment_location,
		std::span(multiline_buffer_.begin(), multiline_index));
}

void lexer::scan_binary_token(token& into) {
	long long number;
	auto scanned = scan_binary_number(number);
	if (!scanned) {
		throw invalid_identifier(source_location());
	}

	auto loc = location();
	advance(scanned);
	into.emplace_token<tokens::constant_value_token>(
		loc, number, tokens::integer_base::binary);
}

std::size_t lexer::scan_decimal_number(long long& into, std::size_t skip) {
	throw std::system_error(std::make_error_code(std::errc::not_supported));
}

std::size_t lexer::scan_octal_number(long long& into,
									 bool bail_on_decimal,
									 std::size_t skip) {
	auto number_location = location();
	std::size_t nc = 0;
	std::size_t taken = 0;
	into = 0;

	char32_t first{};
	while (true) {
		nc = next_code_point(first, skip + taken);
		if (!nc) {
			return taken;
		}

		if (!is_octal_digit(first)) {
			if (bail_on_decimal && is_decimal_digit(first))
				return 0;
			break;
		}

		into = (into * 8) + decimal_value(first);
		taken += nc;
	}

	return taken;
}

std::size_t lexer::scan_binary_number(long long& into, std::size_t skip) {
	auto number_location = location();
	std::size_t nc = 0;
	std::size_t taken = 0;
	into = 0;

	char32_t first{};
	while (true) {
		nc = next_code_point(first, skip + taken);
		if (!nc) {
			return taken;
		}

		if (first != U'0' && first != U'1')
			break;

		into = (into * 2) + (first - U'0');
		taken += nc;
	}

	return taken;
}

bool lexer::scan_octal_token(token& into, bool throw_on_invalid) {
	long long number;
	auto scanned = scan_octal_number(number, false);
	if (!scanned) {
		if (throw_on_invalid)
			throw invalid_identifier(source_location());
		return false;
	}

	auto loc = location();
	advance(scanned);
	into.emplace_token<tokens::constant_value_token>(
		loc, number, tokens::integer_base::octal);
	return true;
}

std::size_t lexer::scan_binary_or_octal_number(long long& into,
											   std::size_t base,
											   std::size_t skip) {
	auto number_location = location();

	bool separator_allowed = false;
	bool got_separator = false;

	std::size_t nc = 0;
	std::size_t taken = 0;

	char32_t first{};
	while (true) {
		nc = next_code_point(first, skip);
		if (!nc) {
			return taken;
		}

		if (!is_octal_digit(first))
			break;

		advance(nc);
		break;
	}

	throw "implementation truncated";
}

void lexer::scan_decimal_token(token& into) {
	auto number_location = location();

	long long number_part = 0;
	std::size_t nc = 0;

	char32_t first{};
	while (true) {
		nc = next_code_point(first);
		if (!nc) {
			into.emplace_token<tokens::constant_value_token>(
				number_location, number_part, tokens::integer_base::decimal);
			return;
		}

		if (!is_decimal_digit(first)) {
			// separators are allowed here
			if (first == U'_') {
				continue;
			}
			break;
		}

		advance(nc);
		number_part = (number_part * 10) + decimal_value(first);
	}

	if (nc && first == '.') {
		advance(nc);

		// parse as a decimal
		long double numerator = 0;
		long long numerator_e = 0;

		while (true) {
			nc = next_code_point(first);
			if (!nc || !is_decimal_digit(first)) {
				if (first == U'.') {
					throw invalid_identifier(number_location);
				}
				break;
			}

			advance(nc);
			numerator = (numerator * 10) + decimal_value(first);
			--numerator_e;
		}

		auto value = static_cast<long double>(number_part) +
					 (numerator * std::pow(10.0L, numerator_e));
		if (nc && (first == 'e' || first == 'E')) {
			advance(nc);
			bool is_upper = first == 'E';

			nc = next_code_point(first);
			if (!nc) {
				throw invalid_identifier(number_location);
			}

			long long exponent = 1;

			switch (first) {
				case '-':
					exponent = -1;
				case '+':
					advance(nc);

					nc = next_code_point(first);
					if (!nc || !is_decimal_digit(first)) {
						throw invalid_identifier(number_location);
					}

					exponent *= decimal_value(first);
					break;
				default:
					if (!is_decimal_digit(first)) {
						throw invalid_identifier(number_location);
					}
					exponent = decimal_value(first);
			}

			advance(nc);

			// this is a double with an e value
			while (true) {
				nc = next_code_point(first);
				if (!nc || !is_decimal_digit(first)) {
					break;
				}

				advance(nc);
				exponent = (exponent * 10) + decimal_value(first);
			}

			into.emplace_token<tokens::constant_value_token>(
				number_location, value, static_cast<int>(exponent), is_upper);
		} else {
			into.emplace_token<tokens::constant_value_token>(number_location,
															 value);
		}

		return;
	}

	if (nc && (first == 'e' || first == 'E')) {
		advance(nc);
		bool is_upper = first == 'E';

		nc = next_code_point(first);
		if (!nc) {
			throw invalid_identifier(number_location);
		}

		long long exponent = 1;

		switch (first) {
			case '-':
				exponent = -1;
			case '+':
				advance(nc);

				nc = next_code_point(first);
				if (!nc || !is_decimal_digit(first)) {
					throw invalid_identifier(number_location);
				}

				exponent *= decimal_value(first);
				break;
			default:
				if (!is_decimal_digit(first)) {
					throw invalid_identifier(number_location);
				}
				exponent = decimal_value(first);
		}

		advance(nc);

		// this is an integer with an e value - convert to long double
		while (true) {
			nc = next_code_point(first);
			if (!nc || !is_decimal_digit(first)) {
				break;
			}

			advance(nc);
			exponent = (exponent * 10) + decimal_value(first);
		}

		into.emplace_token<tokens::constant_value_token>(
			number_location, static_cast<long double>(number_part),
			static_cast<int>(exponent), is_upper);
		return;
	}

	into.emplace_token<tokens::constant_value_token>(
		number_location, number_part, tokens::integer_base::decimal);
}

void lexer::scan_big_integer_token(token& into) {
	throw std::system_error(std::make_error_code(std::errc::not_supported));
}

void lexer::scan_hex_token(token& into) {
	auto number_location = location();
	long long number_part = 0;
	auto scanned = scan_hex_number(number_part, 1, true, true);

	if (!scanned) {
		throw invalid_identifier(number_location);
	}

	advance(scanned);
	into.emplace_token<tokens::constant_value_token>(
		number_location, number_part, tokens::integer_base::hex);
}

void lexer::scan_conflict_marker(token& into) {
	throw std::system_error(std::make_error_code(std::errc::not_supported));
}

bool lexer::scan_jsx_token(token& into) {
	if (source_->language_variant() == ts_language_variant::ts) {
		return false;
	}
	throw std::system_error(std::make_error_code(std::errc::not_supported));
}

void lexer::append_wbuffer(char32_t ch) {
	if (wbuffer_.capacity() == wbuffer_.size()) {
		wbuffer_.reserve(wbuffer_.size() + buffer_size);
	}
	wbuffer_.push_back(ch);
}

std::size_t lexer::scan_hex_number(long long& into,
								   std::size_t min_size,
								   bool scan_as_many_as_possible,
								   bool can_have_separators,
								   std::size_t skip) {
	char32_t ch{};
	std::size_t total_skip = skip;
	std::size_t hex_digits = 0;
	bool prior_was_separator = false;
	char32_t value = 0;

	// Read hex digits until we have enough or hit a non-hex character
	while (true) {
		auto nc = next_code_point(ch, total_skip);
		if (!nc) {
			break;
		}

		// Skip optional separators if allowed
		if (ch == '_') {
			if (!can_have_separators) {
				throw separators_not_allowed_here(location());
			}

			if (prior_was_separator) {
				throw multiple_separators_not_allowed(location());
			}

			prior_was_separator = true;
			total_skip += nc;
			continue;
		}

		prior_was_separator = false;

		// Check if we have a valid hex digit
		if (!is_hex_digit(ch)) {
			break;
		}

		// Convert hex digit to value
		if (ch >= '0' && ch <= '9') {
			value = (value << 4) | (ch - '0');
		} else if (ch >= 'A' && ch <= 'F') {
			value = (value << 4) | (ch - 'A' + 10);
		} else if (ch >= 'a' && ch <= 'f') {
			value = (value << 4) | (ch - 'a' + 10);
		} else if (ch >= 0xff10 && ch <= 0xff19) {
			value = (value << 4) | (ch - 0xff10);
		} else if (ch >= 0xff21 && ch <= 0xff26) {
			value = (value << 4) | (ch - 0xff21 + 10);
		} else if (ch >= 0xff41 && ch <= 0xff46) {
			value = (value << 4) | (ch - 0xff41 + 10);
		}

		hex_digits++;
		total_skip += nc;

		// If we have enough digits and aren't scanning for more, stop
		if (hex_digits >= min_size && !scan_as_many_as_possible) {
			break;
		}
	}

	if (prior_was_separator) {
		throw separators_not_allowed_here(location());
	}

	// If we didn't get enough hex digits, return 0 to indicate failure
	if (hex_digits < min_size) {
		throw hexidecimal_digit_expected(location() + total_skip);
	}

	into = value;
	return total_skip - skip;
}

std::size_t lexer::scan_unicode_escape_into_wbuffer(
	std::size_t min_size,
	bool scan_as_many_as_possible,
	bool can_have_separators) {
	long long result;
	auto scanned = scan_hex_number(result, min_size, scan_as_many_as_possible,
								   can_have_separators);

	if (!scanned)
		throw invalid_identifier(location());

	advance(scanned);
	append_wbuffer(result);
	return scanned;
}

void lexer::scan_identifier(token& into, bool is_private) {
	wbuffer_.clear();
	auto identifier_start = location();

	while (true) {
		char32_t ch{};
		auto pos = next_code_point(ch);

		if (!pos)
			break;

		if (ch == L'\\') {
			char32_t next{};
			auto gs = next_code_point(next, pos);

			auto loc = location();
			if (gs > 0) {
				wbuffer_.clear();
				if (next == U'u') {
					char32_t ucnext{};
					auto ggs = next_code_point(ucnext, pos + gs);
					if (ggs > 0 && ucnext == U'{') {
						advance(pos + gs + ggs);

						auto scanned =
							scan_unicode_escape_into_wbuffer(1, true, false);
						if (!scanned)
							throw invalid_identifier(identifier_start);
						advance(scanned);
						ggs = next_code_point(ucnext);
						if (!is_identifier_part(
								wbuffer_[wbuffer_.size() - 1]) ||
							!ggs || ucnext != U'}') {
							throw invalid_character(loc);
						}

						advance(ggs);
						continue;
					}

					advance(pos + gs);
					auto scanned =
						scan_unicode_escape_into_wbuffer(4, false, false);
					if (!scanned)
						throw invalid_identifier(identifier_start);
					advance(scanned);
					if (!is_identifier_part(wbuffer_[wbuffer_.size() - 1])) {
						throw invalid_character(loc);
					}

					continue;
				}
			}

			throw invalid_character(loc);
		} else if (!is_identifier_part(ch)) {
			break;
		}

		append_wbuffer(ch);
		advance(pos);
	}

	if (wbuffer_.empty() || !is_identifier_start(wbuffer_[0])) {
		throw invalid_identifier(identifier_start);
	}

	auto kit = keyword_lookup.find(wbuffer_);
	if (kit != keyword_lookup.end()) {
		kit->second(into, identifier_start);
		return;
	}

	into.emplace_token<tokens::identifier_token>(identifier_start,
												 std::move(wbuffer_));
}

constexpr bool lexer::is_decimal_digit(char32_t ch) {
	return (ch >= U'0' && ch <= U'9') || (ch >= 0xff10 && ch <= 0xff19);
}

constexpr long long lexer::decimal_value(char32_t ch) {
	if (ch >= 0xff10) {
		return ch - 0xff10;
	}

	return ch - U'0';
}

constexpr bool lexer::is_octal_digit(char32_t ch) {
	return (ch >= U'0' && ch < U'8') || (ch >= 0xff10 && ch < 0xff18);
}

constexpr bool lexer::is_hex_digit(char32_t ch) {
	return (ch >= U'0' && ch <= U'8') || (ch >= U'A' && ch <= U'F') ||
		   (ch >= U'a' && ch <= U'f') || (ch >= 0xff21 && ch <= 0xff26) ||
		   (ch >= 0xff41 && ch <= 0xff46) || (ch >= 0xff10 && ch <= 0xff18);
}

constexpr bool lexer::is_alpha(char32_t ch) {
	return (ch >= U'A' && ch <= U'Z') || (ch >= U'a' && ch <= U'z') ||
		   (ch >= 0xff21 && ch <= 0xff3a) || (ch >= 0xff41 && ch <= 0xff5a);
}

constexpr bool lexer::is_identifier_part(char32_t ch, bool is_jsx) {
	// A-Za-z0-9
	if ((ch >= U'A' && ch <= U'Z') || (ch >= U'a' && ch <= U'z') ||
		(ch >= U'0' && ch <= U'9'))
		return true;

	if (ch == U'$' || ch == U'_')
		return true;

	if (is_jsx && (ch == '-' || ch == ':'))
		return true;

	if (ch > 0x7f) {
		if (vers_ >= language_version::es2015) {
			auto fnd =
				std::lower_bound(unicode_esnext_identifier_part.begin(),
								 unicode_esnext_identifier_part.end(), ch);
			return fnd != unicode_esnext_identifier_part.end() && *fnd == ch;
		}

		if (vers_ >= language_version::es5) {
			auto fnd = std::lower_bound(unicode_es5_identifier_part.begin(),
										unicode_es5_identifier_part.end(), ch);
			return fnd != unicode_es5_identifier_part.end() && *fnd == ch;
		}

		auto fnd = std::lower_bound(unicode_es3_identifier_part.begin(),
									unicode_es3_identifier_part.end(), ch);
		return fnd != unicode_es3_identifier_part.end() && *fnd == ch;
	}

	return false;
}

constexpr bool lexer::is_identifier_start(char32_t ch) {
	// A-Za-z0-9
	if ((ch >= U'A' && ch <= U'Z') || (ch >= U'a' && ch <= U'z') ||
		(ch >= U'0' && ch <= U'9'))
		return true;

	if (ch == U'$' || ch == U'_')
		return true;

	if (ch > 0x7f) {
		if (vers_ >= language_version::es2015) {
			auto fnd =
				std::lower_bound(unicode_esnext_identifier_start.begin(),
								 unicode_esnext_identifier_start.end(), ch);
			return fnd != unicode_esnext_identifier_start.end() && *fnd == ch;
		}

		if (vers_ >= language_version::es5) {
			auto fnd = std::lower_bound(unicode_es5_identifier_start.begin(),
										unicode_es5_identifier_start.end(), ch);
			return fnd != unicode_es5_identifier_start.end() && *fnd == ch;
		}

		auto fnd = std::lower_bound(unicode_es3_identifier_start.begin(),
									unicode_es3_identifier_start.end(), ch);
		return fnd != unicode_es3_identifier_start.end() && *fnd == ch;
	}

	return false;
}

void lexer::scan_line_into_wbuffer(bool trim) {
	char32_t first{};

	// skip any whitespace
	while (true) {
		auto nc = next_code_point(first);
		if (!nc) {
			wbuffer_.clear();
			return;
		}

		advance(nc);
		if (!trim || !std::iswspace(first))
			break;
	}

	wbuffer_.reserve(buffer_size);
	wbuffer_.assign(&first, 1);

	// read the command until a eof or an eol
	while (true) {
		auto nc = next_code_point(first);
		if (!nc) {
			if (trim) {
				// trim any whitespace off of the end
				std::size_t end = wbuffer_.size();
				while (std::iswspace(wbuffer_[end - 1])) {
					end--;
				}

				wbuffer_.erase(end);
			}
			return;
		}

		advance(nc);
		if (first == '\n') {
			if (trim) {
				// trim any whitespace off of the end
				std::size_t end = wbuffer_.size();
				while (std::iswspace(wbuffer_[end - 1])) {
					end--;
				}

				wbuffer_.erase(end);
			}
			gpos_.advance_line();
			return;
		}

		append_wbuffer(first);
	}
}

bool lexer::scan(token& into) {
	while (true) {
		char32_t ch{};
		auto pos = next_code_point(ch);

		if (!pos)
			return false;

		// check for shebang
		if (gpos_.offset == 0 && ch == U'#') {
			char32_t next{};
			auto gs = next_code_point(next, pos);
			if ((gs > 0) && next == U'!') {
				scan_shebang(pos + gs, into);
				return true;
			}
		}

		if (ch == '\r') {
			char32_t next{};
			auto gs = next_code_point(next, pos);

			auto loc = location();
			if ((gs > 0) && next == L'\n') {
				pos += gs;
			}

			advance(pos);
			gpos_.advance_line();
			if (pnewline_)
				continue;

			pnewline_ = true;
			into.emplace_token<tokens::newline_token>(loc);
			return true;
		}

		if (ch == '\n') {
			auto loc = location();
			advance(pos);
			gpos_.advance_line();

			if (pnewline_)
				continue;

			pnewline_ = true;
			into.emplace_token<tokens::newline_token>(loc);
			return true;
		}

		pnewline_ = false;
		switch (ch) {
			case L'\t':	  // tab
			case 0x0b:	  // vertical tab
			case 0x0c:	  // form feed
			case U' ':	  // space
			case 0xa0:	  // nbsp
			case 0x1680:  // ogham space
			case 0x2000:  // en quad
			case 0x2001:  // em quad
			case 0x2002:  // en space
			case 0x2003:  // em space
			case 0x2004:  // three per em space
			case 0x2005:  // four per em space
			case 0x2006:  // six per em space
			case 0x2007:  // figure space
			case 0x2008:  // punctuation space
			case 0x2009:  // thin space
			case 0x200a:  // hair space
			case 0x200b:  // zero-width space
			case 0x202f:  // narrow no break space
			case 0x205f:  // medium mathematical space
			case 0x3000:  // ideographic space
			case 0xfeff:  // zero-width nbsp / bom
				advance(pos);
				break;
			case U'!': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						char32_t excnext{};
						auto ggs = next_code_point(excnext, pos + gs);
						if (ggs > 0 && excnext == '=') {
							advance(pos + gs + ggs);
							into.emplace_token<tokens::exclamation_eq_eq_token>(
								loc);
							return true;
						}

						advance(pos + gs);
						into.emplace_token<tokens::exclamation_eq_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::exclamation_token>(loc);
				return true;
			}
			case U'"':
			case U'\'':
				scan_string(into);
				return true;
			case U'`':
				scan_string_template(into);
				return true;
			case U'%': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if ((gs > 0) && next == U'=') {
					advance(pos + gs);
					into.emplace_token<tokens::percent_eq_token>(loc);
					return true;
				}

				advance(pos);
				into.emplace_token<tokens::percent_token>(loc);
				return true;
			}
			case U'&': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::ampersand_eq_token>(loc);
						return true;
					}

					if (next == U'&') {
						char32_t ampnext{};
						auto ggs = next_code_point(ampnext, pos + gs);
						if (ggs > 0 && ampnext == '=') {
							advance(pos + gs + ggs);
							into.emplace_token<
								tokens::double_ampersand_eq_token>(loc);
							return true;
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_ampersand_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::ampersand_token>(loc);
				return true;
			}
			case U'(':
				into.emplace_token<tokens::open_paren_token>(location());
				advance(pos);
				return true;
			case U')':
				into.emplace_token<tokens::close_paren_token>(location());
				advance(pos);
				return true;
			case U'*': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::asterisk_eq_token>(loc);
						return true;
					}

					if (next == U'*') {
						char32_t astnext{};
						auto ggs = next_code_point(astnext, pos + gs);
						if (ggs > 0 && astnext == '=') {
							advance(pos + gs + ggs);
							into.emplace_token<
								tokens::double_asterisk_eq_token>(loc);
							return true;
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_asterisk_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::asterisk_token>(loc);
				return true;
			}
			case U'+': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'+') {
						advance(pos + gs);
						into.emplace_token<tokens::double_plus_token>(loc);
						return true;
					}

					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::plus_eq_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::plus_token>(loc);
				return true;
			}
			case U',':
				into.emplace_token<tokens::comma_token>(location());
				advance(pos);
				return true;
			case U'-': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'-') {
						advance(pos + gs);
						into.emplace_token<tokens::double_minus_token>(loc);
						return true;
					}

					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::minus_eq_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::minus_token>(loc);
				return true;
			}
			case U'.': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'.') {
						char32_t dotnext{};
						auto ggs = next_code_point(dotnext, pos + gs);
						if (ggs > 0 && dotnext == '.') {
							advance(pos + gs + ggs);
							into.emplace_token<tokens::triple_dot_token>(loc);
							return true;
						}
					} else if (is_decimal_digit(next)) {
						scan_decimal_token(into);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::dot_token>(loc);
				return true;
			}
			case U'/': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::slash_eq_token>(loc);
						return true;
					}

					if (next == U'/') {
						scan_line_comment(pos + gs, into);
						return true;
					}

					if (next == U'*') {
						bool is_jsdoc = false;

						char32_t astnext{};
						auto ggs = next_code_point(astnext, pos + gs);
						if (ggs > 0 && astnext == '*') {
							char32_t verify_jsdoc_char;
							auto verify_gs = next_code_point(verify_jsdoc_char,
															 pos + gs + ggs);

							if (verify_gs && verify_jsdoc_char != '*') {
								gs += ggs;
								is_jsdoc = true;
							}
						}

						advance(pos + gs);
						scan_multiline_comment(into, is_jsdoc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::slash_token>(loc);
				return true;
			}
			case U'0': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == 'x' || next == 'X') {
						advance(pos + gs);
						scan_hex_token(into);
						return true;
					}

					if (next == 'b' || next == 'B') {
						advance(pos + gs);
						scan_binary_token(into);
						return true;
					}

					if (next == 'o' || next == 'O') {
						advance(pos + gs);
						scan_octal_token(into);
						return true;
					}

					if (next == 'n' || next == 'N') {
						advance(pos + gs);
						scan_big_integer_token(into);
						return true;
					}

					// try to parse an octal number
					if (is_octal_digit(next)) {
						long long octal_value;
						auto taken =
							scan_octal_number(octal_value, true, pos + gs);
						if (taken) {
							into.emplace_token<tokens::constant_value_token>(
								location(), octal_value,
								tokens::integer_base::octal);
							advance(pos + gs + taken);
						} else {
							advance(pos);
							scan_decimal_token(into);
						}
						return true;
					}
				}
			}
			case U'1':
			case U'2':
			case U'3':
			case U'4':
			case U'5':
			case U'6':
			case U'7':
			case U'8':
			case U'9':
				scan_decimal_token(into);
				return true;
			case U':':
				into.emplace_token<tokens::colon_token>(location());
				advance(pos);
				return true;
			case U';':
				into.emplace_token<tokens::semicolon_token>(location());
				advance(pos);
				return true;
			case U'<': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::less_eq_token>(loc);
						return true;
					}

					if (next == U'<') {
						char32_t ltnext{};
						auto ggs = next_code_point(ltnext, pos + gs);
						if (ggs > 0) {
							if (ltnext == U'<') {
								scan_conflict_marker(into);
								return true;
							}

							if (ltnext == U'=') {
								advance(pos + gs + ggs);
								into.emplace_token<
									tokens::double_less_eq_token>(loc);
								return true;
							}
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_less_token>(loc);
						return true;
					}

					if (is_alpha(next)) {
						if (scan_jsx_token(into)) {
							return true;
						}
					}
				}

				advance(pos);
				into.emplace_token<tokens::less_token>(loc);
				return true;
			}
			case U'=': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						char32_t eqnext{};
						auto ggs = next_code_point(eqnext, pos + gs);
						if (ggs > 0) {
							if (eqnext == U'=') {
								char32_t eenext{};
								auto gggs =
									next_code_point(eenext, pos + gs + ggs);

								if (gggs > 0 && eenext == U'=') {
									scan_conflict_marker(into);
									return true;
								}

								advance(pos + gs + ggs);
								into.emplace_token<tokens::triple_eq_token>(
									loc);
								return true;
							}
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_eq_token>(loc);
						return true;
					}

					if (next == U'>') {
						advance(pos + gs);
						into.emplace_token<tokens::eq_greater_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::eq_token>(loc);
				return true;
			}
			case U'>': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::greater_eq_token>(loc);
						return true;
					}

					if (next == U'>') {
						char32_t gtnext{};
						auto ggs = next_code_point(gtnext, pos + gs);
						if (ggs > 0) {
							if (gtnext == U'>') {
								scan_conflict_marker(into);
								return true;
							}

							if (gtnext == U'=') {
								advance(pos + gs + ggs);
								into.emplace_token<
									tokens::double_greater_eq_token>(loc);
								return true;
							}
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_greater_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::greater_token>(loc);
				return true;
			}
			case U'?': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					char32_t qnext{};
					auto ggs = next_code_point(qnext, pos + gs);

					if (next == U'.' &&
						(ggs == 0 || is_identifier_start(qnext) &&
										 !is_decimal_digit(qnext))) {
						advance(pos + gs);
						into.emplace_token<tokens::question_dot_token>(loc);
						return true;
					}

					if (next == U'?') {
						if ((ggs > 0) && qnext == U'=') {
							advance(pos + gs + ggs);
							into.emplace_token<
								tokens::double_question_eq_token>(loc);
							return true;
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_question_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::question_token>(loc);
				return true;
			}
			case U'[':
				into.emplace_token<tokens::open_bracket_token>(location());
				advance(pos);
				return true;
			case U']':
				into.emplace_token<tokens::close_bracket_token>(location());
				advance(pos);
				return true;
			case U'^': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if ((gs > 0) && next == U'=') {
					advance(pos + gs);
					into.emplace_token<tokens::caret_eq_token>(loc);
					return true;
				}

				advance(pos);
				into.emplace_token<tokens::caret_token>(loc);
				return true;
			}
			case U'{':
				into.emplace_token<tokens::open_brace_token>(location());
				advance(pos);
				return true;
			case U'|': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == U'=') {
						advance(pos + gs);
						into.emplace_token<tokens::bar_eq_token>(loc);
						return true;
					}

					if (next == U'|') {
						char32_t gtnext{};
						auto ggs = next_code_point(gtnext, pos + gs);
						if (ggs > 0) {
							if (gtnext == U'|') {
								scan_conflict_marker(into);
								return true;
							}

							if (gtnext == U'=') {
								advance(pos + gs + ggs);
								into.emplace_token<tokens::double_bar_eq_token>(
									loc);
								return true;
							}
						}

						advance(pos + gs);
						into.emplace_token<tokens::double_bar_token>(loc);
						return true;
					}
				}

				advance(pos);
				into.emplace_token<tokens::bar_token>(loc);
				return true;
			}
			case U'}':
				into.emplace_token<tokens::close_brace_token>(location());
				advance(pos);
				return true;
			case U'~':
				into.emplace_token<tokens::tilde_token>(location());
				advance(pos);
				return true;
			case U'@':
				into.emplace_token<tokens::at_token>(location());
				advance(pos);
				return true;
			case U'#': {
				char32_t next{};
				auto gs = next_code_point(next, pos);

				auto loc = location();
				if (gs > 0) {
					if (next == '!') {
						throw misplaced_shebang(loc);
					}

					advance(pos);
					scan_identifier(into, true);
					return true;
				}

				throw invalid_character(loc);
			}
			default:
				scan_identifier(into);
				return true;
		}
	}
}

source_location lexer::location() const {
	// get the column
	auto column = gpos_.offset - gpos_.line.line_start_offset;
	return source_location{source_, gpos_.line.current_line_number, column,
						   gpos_.offset};
}
